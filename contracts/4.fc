{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption and decryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encrypted in a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters and the last ASCII
  character should go to the beginning. Return new text encoded in cell.
-}

() recv_internal() {
}

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
  ;;~dump(text.begin_parse().slice_refs());
  slice s = text.begin_parse();
  s~load_uint(32);
  cell r = caesar_cipher(shift, s, -1);
  ;;~dump(r.begin_parse().slice_refs());

  return r;
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
  shift = -1 * shift + 26;
  slice s = text.begin_parse();
  s~load_uint(32);
  return caesar_cipher(shift, s, -1);
}

(cell) caesar_cipher(int shift, slice s, int is_initial) inline {
  {- if (amount < 0) {
    return caesarShift(str, amount + 26);
  } -}
 ;; ~dump(s.slice_bits());

  builder b = begin_cell();
  if (is_initial) {
    b~store_uint(0, 32);
  }

  while (~ s.slice_data_empty?()) {
      int char = s~load_uint(8);

      if ((char >= 65) & (char <= 90)) {
          char = ((char - 65 + shift) % 26) + 65;
      } elseif ((char >= 97) & (char <= 122)) {
          char = ((char - 97 + shift) % 26) + 97;
      }

      b~store_uint(char, 8);
  }

  if (~ s.slice_refs_empty?()) {
    cell child = caesar_cipher(shift, s~load_ref().begin_parse(), 0);
    ;;~dump(b.store_ref(child).end_cell().begin_parse().slice_bits());
    return b.store_ref(child).end_cell();
  }

  ;;~dump(b.end_cell().begin_parse().slice_bits());

  return b.end_cell();
  {-
   if (s.slice_data_empty?()) {
      builder next = begin_cell();
      b~store_ref(next);
      b.end_cell();
      b = next;

      s = s~load_ref().begin_parse();
    }
  // Make an output variable
          var output = "";

  // Go through each character
          for (var i = 0; i < str.length; i++) {
          // Get the character we'll be appending
                  var c = str[i];

          // If it's a letter...
          if (c.match(/[a-z]/i)) {
          // Get its code
                  var code = str.charCodeAt(i);

          // Uppercase letters
          if (code >= 65 && code <= 90) {
          c = String.fromCharCode(((code - 65 + amount) % 26) + 65);
          }

          // Lowercase letters
                  else if (code >= 97 && code <= 122) {
          c = String.fromCharCode(((code - 97 + amount) % 26) + 97);
          }
          }

          // Append
                  output += c;
          }

  // All done!
  return output;

  -}
}
